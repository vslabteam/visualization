<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>银行欺诈数据可视化</title>
    <script src="https://gw.alipayobjects.com/os/lib/antv/g6/5.0.27/dist/g6.min.js"></script>
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
    <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-4.6.9/dist/g6.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            min-height: 100vh;
            width: 100vw;
            position: fixed;
            overflow: hidden;
        }

        .left-panel {
            width: 300px;
            background: #f0f2f5;
            padding: 20px;
            border-right: 1px solid #e8e8e8;
            overflow-y: auto;
            height: 100vh;
        }

        .center-panel {
            flex: 1;
            position: relative;
            height: 100vh;
        }

        .right-panel {
            width: 300px;
            background: #f0f2f5;
            padding: 20px;
            border-left: 1px solid #e8e8e8;
            overflow-y: auto;
            height: 100vh;
        }

        #container {
            width: 100%;
            height: 100%;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #1890ff;
        }

        .info-item {
            margin-bottom: 15px;
        }

        .info-label {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .control-item {
            margin-bottom: 20px;
        }

        .control-button {
            padding: 8px 15px;
            background: #1890ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
        }

        .control-button:hover {
            background: #40a9ff;
        }

        .stats-container {
            background: white;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .algorithm-results {
            background: white;
            border-radius: 4px;
            margin-top: 10px;
        }

        .result-container {
            padding: 15px;
        }

        .result-item {
            margin-bottom: 20px;
        }

        .result-content {
            padding: 10px;
            background: #f8f8f8;
            border-radius: 4px;
            margin-top: 5px;
        }

        .top-nodes ul {
            list-style: none;
            padding-left: 10px;
        }

        .top-nodes li {
            margin: 5px 0;
            color: #666;
        }

        .highlight-node {
            color: #1890ff;
            font-weight: bold;
        }

        .highlight-path {
            stroke: #ff4d4f !important;
            stroke-width: 3px !important;
        }

        .highlight-community {
            opacity: 0.7;
        }

        .g6-minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            border: 1px solid #e2e2e2;
            background: #fff;
        }

        .error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff1f0;
            border: 1px solid #ffa39e;
            padding: 15px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
        }

        .loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="left-panel">
        <div class="panel-title">图表信息</div>
        <div class="stats-container">
            <div class="info-item">
                <div class="info-label">节点总数</div>
                <div id="nodeCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">边总数</div>
                <div id="edgeCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">账户节点数</div>
                <div id="accountCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">交易节点</div>
                <div id="transactionCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">商户节点数</div>
                <div id="merchantCount">0</div>
            </div>
        </div>

        <div class="panel-title">算法分析结果</div>
        <div class="algorithm-results">
            <div class="result-container">
                <div class="result-item">
                    <div class="info-label">中心度分析</div>
                    <div id="centralityResult" class="result-content">
                        <div class="top-nodes">
                            <h4>重要节点 Top5：</h4>
                            <ul id="centralityTop5"></ul>
                        </div>
                    </div>
                </div>
                <div class="result-item">
                    <div class="info-label">社区检测</div>
                    <div id="communityResult" class="result-content">
                        <div>社区数量：<span id="communityCount">0</span></div>
                        <div>最大社区规模：<span id="maxCommunitySize">0</span></div>
                    </div>
                </div>
                <div class="result-item">
                    <div class="info-label">路径分析</div>
                    <div id="pathResult" class="result-content">
                        <div>平均路径长度：<span id="avgPathLength">0</span></div>
                        <div>最长路径：<span id="maxPathLength">0</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="center-panel">
        <div id="container"></div>
    </div>

    <div class="right-panel">
        <div class="panel-title">操作面板</div>
        <div class="control-item">
            <button class="control-button" onclick="zoomIn()">放大</button>
            <button class="control-button" onclick="zoomOut()">缩小</button>
            <button class="control-button" onclick="resetZoom()">重置缩放</button>
        </div>
        <div class="control-item">
            <button class="control-button" onclick="fitView()">适应画布</button>
            <button class="control-button" onclick="toggleNodeLabels()">显示/隐藏签</button>
        </div>
        <div class="control-item">
            <div class="info-label">节点大小</div>
            <input type="range" min="10" max="50" value="20" 
                   onchange="updateNodeSize(this.value)" style="width: 100%;">
        </div>
        <div class="control-item">
            <div class="info-label">线粗细</div>
            <input type="range" min="1" max="10" value="2" 
                   onchange="updateEdgeWidth(this.value)" style="width: 100%;">
        </div>
        <div class="control-item">
            <div class="info-label">动画效���</div>
            <button class="control-button" onclick="toggleEdgeAnimation()">边动画效果</button>
            <button class="control-button" onclick="toggleNodeAnimation()">节点呼吸效果</button>
        </div>
        <div class="control-item">
            <div class="info-label">节点筛选</div>
            <select id="nodeFilter" onchange="filterNodes()" style="width: 100%; padding: 8px;">
                <option value="all">显示所有</option>
                <option value="account">仅账户节点</option>
                <option value="transaction">仅交易节点</option>
                <option value="merchant">仅商户节点</option>
            </select>
        </div>
        <div class="control-item">
            <div class="info-label">布局方式</div>
            <select id="layoutSelect" onchange="changeLayout()" style="width: 100%; padding: 8px;">
                <option value="force">力导向布局</option>
                <option value="circular">环形布局</option>
                <option value="radial">辐射布局</option>
                <option value="dagre">层次布局</option>
                <option value="concentric">同心圆布局</option>
            </select>
        </div>
        <div class="control-item" id="layoutParams">
            <div class="info-label">布局参数</div>
            <div id="forceParams" style="display: none;">
                <input type="range" min="50" max="300" value="100" 
                       onchange="updateForceDistance(this.value)" style="width: 100%;">
                <label>链接距离</label>
            </div>
        </div>
        <div class="control-item">
            <button class="control-button" onclick="exportImage('png')">导出为PNG</button>
            <button class="control-button" onclick="exportImage('svg')">导出为SVG</button>
        </div>
        <div class="control-item">
            <div class="info-label">主题切换</div>
            <select id="themeSelect" onchange="changeTheme()" style="width: 100%; padding: 8px;">
                <option value="default">默认主题</option>
                <option value="dark">暗黑主题</option>
                <option value="colorful">多彩主题</option>
            </select>
        </div>
        <div class="control-item">
            <div class="info-label">边特效</div>
            <select id="edgeEffect" onchange="changeEdgeEffect()" style="width: 100%; padding: 8px;">
                <option value="none">无特效</option>
                <option value="flow">流动效果</option>
                <option value="glow">发光效果</option>
            </select>
        </div>
        <div class="control-item">
            <button class="control-button" onclick="toggleStats()">切换性能监控</button>
        </div>
        <div class="control-item">
            <div class="info-label">图算法</div>
            <select id="algorithmSelect" style="width: 100%; padding: 8px; margin-bottom: 10px;">
                <option value="centrality">中心度分析</option>
                <option value="community">社区检测</option>
                <option value="shortestPath">最短路径</option>
                <option value="cycle">环路检测</option>
            </select>
            <button class="control-button" onclick="runAlgorithm()">运行算法</button>
        </div>
        <div id="algorithmParams" class="control-item">
            <!-- 动态显示不同算法的参数设置 -->
        </div>
    </div>

    <script src="dataWorker.js"></script>

    <script>
        let showLabels = true;

        // 注册自定义节点
        const fraudNode = {
            draw: (model, group) => {
                const { type } = model;
                const imageMap = {
                    'account': 'images/account.svg',
                    'transaction': 'images/transaction.svg',
                    'merchant': 'images/merchant.svg'
                };

                const keyShape = group.addShape('circle', {
                    attrs: {
                        x: 0,
                        y: 0,
                        r: 20,
                        fill: '#fff',
                        stroke: '#1890ff',
                        lineWidth: 2
                    },
                    name: 'key-shape'
                });

                group.addShape('image', {
                    attrs: {
                        x: -15,
                        y: -15,
                        width: 30,
                        height: 30,
                        img: imageMap[type] || 'images/default.svg'
                    },
                    name: 'image-shape'
                });

                if (showLabels) {
                    group.addShape('text', {
                        attrs: {
                            text: model.label || '',
                            x: 0,
                            y: 35,
                            textAlign: 'center',
                            textBaseline: 'middle',
                            fill: '#666',
                            fontSize: 12
                        },
                        name: 'text-shape'
                    });
                }

                return keyShape;
            }
        };

        // 初始化性能监控
        const stats = new Stats();
        stats.showPanel(0);
        let showStats = false;

        // 主题配置
        const themes = {
            default: {
                node: {
                    style: {
                        fill: '#fff',
                        stroke: '#1890ff',
                        lineWidth: 2
                    }
                },
                edge: {
                    style: {
                        stroke: '#91d5ff',
                        lineWidth: 2
                    }
                }
            },
            dark: {
                node: {
                    style: {
                        fill: '#2b2b2b',
                        stroke: '#fff',
                        lineWidth: 2
                    }
                },
                edge: {
                    style: {
                        stroke: '#fff',
                        lineWidth: 2
                    }
                }
            },
            colorful: {
                node: {
                    style: {
                        fill: '#fff',
                        stroke: (node) => {
                            const colors = {
                                account: '#ff4d4f',
                                transaction: '#52c41a',
                                merchant: '#1890ff'
                            };
                            return colors[node.type] || '#666';
                        },
                        lineWidth: 2
                    }
                },
                edge: {
                    style: {
                        stroke: '#f6bd16',
                        lineWidth: 2
                    }
                }
            }
        };

        // 初始化图表
        function initGraph() {
            const container = document.getElementById('container');
            if (!container) {
                console.error('容器元素不存在');
                return null;
            }

            // 注册自定义节点
            G6.registerNode('fraud-node', fraudNode);

            const width = container.offsetWidth || 800;
            const height = container.offsetHeight || 600;

            const graph = new G6.Graph({
                container: 'container',
                width,
                height,
                modes: {
                    default: ['drag-canvas', 'zoom-canvas', 'drag-node']
                },
                defaultNode: {
                    type: 'fraud-node',
                    size: 20,
                    style: {
                        fill: '#fff',
                        stroke: '#1890ff',
                        lineWidth: 2
                    }
                },
                defaultEdge: {
                    style: {
                        stroke: '#91d5ff',
                        lineWidth: 2
                    }
                },
                layout: {
                    type: 'force',
                    preventOverlap: true,
                    linkDistance: 100,
                    nodeStrength: -50,
                    edgeStrength: 0.1
                },
                plugins: [
                    new G6.Minimap({
                        size: [150, 100]
                    })
                ]
            });

            return graph;
        }

        // 更新统计信息
        function updateStats(data) {
            document.getElementById('nodeCount').textContent = data.nodes.length;
            document.getElementById('edgeCount').textContent = data.edges.length;
            document.getElementById('accountCount').textContent = 
                data.nodes.filter(node => node.type === 'account').length;
            document.getElementById('transactionCount').textContent = 
                data.nodes.filter(node => node.type === 'transaction').length;
            document.getElementById('merchantCount').textContent = 
                data.nodes.filter(node => node.type === 'merchant').length;
        }

        // 控制函数
        function zoomIn() {
            graph.zoom(1.2);
        }

        function zoomOut() {
            graph.zoom(0.8);
        }

        function resetZoom() {
            graph.zoomTo(1);
        }

        function fitView() {
            graph.fitView();
        }

        function toggleNodeLabels() {
            showLabels = !showLabels;
            graph.refresh();
        }

        function changeLayout() {
            const layoutType = document.getElementById('layoutSelect').value;
            const forceParams = document.getElementById('forceParams');
            forceParams.style.display = layoutType === 'force' ? 'block' : 'none';

            const layoutConfig = {
                force: {
                    type: 'force',
                    preventOverlap: true,
                    linkDistance: 100
                },
                circular: {
                    type: 'circular',
                    preventOverlap: true,
                    radius: 200
                },
                radial: {
                    type: 'radial',
                    preventOverlap: true,
                    unitRadius: 100
                },
                dagre: {
                    type: 'dagre',
                    rankdir: 'LR',
                    align: 'DL',
                    nodesep: 20,
                    ranksep: 50
                },
                concentric: {
                    type: 'concentric',
                    preventOverlap: true,
                    minNodeSpacing: 30
                }
            };
            
            graph.updateLayout(layoutConfig[layoutType]);
        }

        // 更新节点大小
        function updateNodeSize(size) {
            graph.updateNodes(graph.getNodes(), node => {
                return {
                    size: Number(size)
                };
            });
        }

        // 更新边的粗细
        function updateEdgeWidth(width) {
            graph.updateEdges(graph.getEdges(), edge => {
                return {
                    style: {
                        ...edge.getModel().style,
                        lineWidth: Number(width)
                    }
                };
            });
        }

        // 边动画效果
        function toggleEdgeAnimation() {
            const edges = graph.getEdges();
            edges.forEach(edge => {
                const animate = edge.get('animating');
                if (!animate) {
                    graph.updateItem(edge, {
                        style: {
                            lineDash: [4, 4],
                            lineDashOffset: 0,
                            animation: {
                                lineDashOffset: -20,
                                repeat: true,
                                duration: 1000
                            }
                        }
                    });
                } else {
                    graph.updateItem(edge, {
                        style: {
                            lineDash: null,
                            animation: null
                        }
                    });
                }
                edge.set('animating', !animate);
            });
        }

        // 节点呼吸效果
        function toggleNodeAnimation() {
            const nodes = graph.getNodes();
            nodes.forEach(node => {
                const animate = node.get('animating');
                if (!animate) {
                    node.get('group').addAnimation({
                        repeat: true,
                        duration: 2000,
                        callback: (ratio) => {
                            const r = 20 + Math.sin(ratio * Math.PI * 2) * 5;
                            node.get('group').getFirst().attr('r', r);
                        }
                    });
                } else {
                    node.get('group').stopAnimate();
                    node.get('group').getFirst().attr('r', 20);
                }
                node.set('animating', !animate);
            });
        }

        // 节点筛选
        function filterNodes() {
            const type = document.getElementById('nodeFilter').value;
            graph.getNodes().forEach(node => {
                const nodeType = node.getModel().type;
                if (type === 'all' || type === nodeType) {
                    graph.showItem(node);
                } else {
                    graph.hideItem(node);
                }
            });
        }

        // 导出图片
        function exportImage(type) {
            if (type === 'png') {
                graph.downloadFullImage('graph-export', 'image/png', {
                    backgroundColor: '#fff'
                });
            } else {
                graph.toFullDataURL('image/svg+xml', (dataUrl) => {
                    const link = document.createElement('a');
                    link.download = 'graph-export.svg';
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                });
            }
        }

        // 更新力导向布局参数
        function updateForceDistance(distance) {
            if (document.getElementById('layoutSelect').value === 'force') {
                graph.updateLayout({
                    type: 'force',
                    preventOverlap: true,
                    linkDistance: Number(distance)
                });
            }
        }

        // 更新主题
        function changeTheme() {
            const theme = document.getElementById('themeSelect').value;
            const themeConfig = themes[theme];
            
            graph.updateTheme({
                node: themeConfig.node,
                edge: themeConfig.edge
            });
        }

        // 边特效
        function changeEdgeEffect() {
            const effect = document.getElementById('edgeEffect').value;
            const edges = graph.getEdges();
            
            edges.forEach(edge => {
                switch(effect) {
                    case 'flow':
                        edge.update({
                            style: {
                                lineDash: [4, 4],
                                lineDashOffset: 0,
                                animation: {
                                    lineDashOffset: -20,
                                    repeat: true,
                                    duration: 1000
                                }
                            }
                        });
                        break;
                    case 'glow':
                        edge.update({
                            style: {
                                lineWidth: 3,
                                shadowColor: '#fff',
                                shadowBlur: 10,
                                animation: {
                                    shadowBlur: 20,
                                    repeat: true,
                                    duration: 2000
                                }
                            }
                        });
                        break;
                    default:
                        edge.update({
                            style: {
                                lineDash: null,
                                animation: null,
                                shadowBlur: 0
                            }
                        });
                }
            });
        }

        // 切换性能监控
        function toggleStats() {
            showStats = !showStats;
            if (showStats) {
                document.body.appendChild(stats.dom);
                animate();
            } else {
                document.body.removeChild(stats.dom);
            }
        }

        function animate() {
            if (showStats) {
                stats.begin();
                stats.end();
                requestAnimationFrame(animate);
            }
        }

        // 初始化和加载数据
        const graph = initGraph(); // Ensure 'graph' is declared only once
        if (graph) {
            fetch('dataset/bankFraud.json')
                .then(async res => {
                    if (!res.ok) {
                        throw new Error(`HTTP error! status: ${res.status}`);
                    }
                    try {
                        const rawData = await res.json();
                        console.log('原始数据:', rawData);
                        const dataWorker = new DataWorker(rawData);
                        const processedData = dataWorker.processData();
                        console.log('处理后的数据:', processedData);
                        
                        graph.data(processedData);
                        graph.render();
                        updateStats(processedData);
                        
                        // 添加窗口大小变化监听
                        window.addEventListener('resize', () => {
                            if (graph && typeof graph.changeSize === 'function') {
                                const container = document.querySelector('.center-panel');
                                if (container) {
                                    graph.changeSize(container.offsetWidth, container.offsetHeight);
                                    graph.fitView();
                                }
                            }
                        });
                    } catch (e) {
                        console.error('数据处理错误:', e);
                        throw e;
                    }
                })
                .catch(err => {
                    console.error('加载数据失败:', err);
                    alert('数据加载失败，请检查数据文件格式是否正确');
                });
        }

        // 响应式调整
        window.addEventListener('resize', () => {
            if (graph) {
                graph.changeSize(
                    document.querySelector('.center-panel').offsetWidth,
                    document.querySelector('.center-panel').offsetHeight
                );
            }
        });

        // 图算法实现
        const GraphAlgorithms = {
            // 中心度分析
            calculateCentrality() {
                const nodes = graph.getNodes();
                const edges = graph.getEdges();
                const centrality = {};
                
                // 计算度中心性
                nodes.forEach(node => {
                    const nodeId = node.getModel().id;
                    centrality[nodeId] = edges.filter(edge => {
                        const model = edge.getModel();
                        return model.source === nodeId || model.target === nodeId;
                    }).length;
                });

                // 排序并返回结果
                return Object.entries(centrality)
                    .sort(([, a], [, b]) => b - a)
                    .slice(0, 5);
            },

            // 社区检测（使用简化的 Louvain 算法）
            detectCommunities() {
                const nodes = graph.getNodes();
                const edges = graph.getEdges();
                const communities = new Map();
                let communityId = 0;

                // 初始化社区，每个节点作为一个社区
                nodes.forEach(node => {
                    const nodeId = node.getModel().id;
                    communities.set(nodeId, communityId++);
                });

                // 简单的社区合并策
                edges.forEach(edge => {
                    const model = edge.getModel();
                    const sourceComm = communities.get(model.source);
                    const targetComm = communities.get(model.target);
                    
                    // 将高ID的社区合并到低ID的社区
                    if (sourceComm !== targetComm) {
                        const newComm = Math.min(sourceComm, targetComm);
                        communities.set(model.source, newComm);
                        communities.set(model.target, newComm);
                    }
                });

                // 整理社区结果
                const communityGroups = new Map();
                communities.forEach((commId, nodeId) => {
                    if (!communityGroups.has(commId)) {
                        communityGroups.set(commId, []);
                    }
                    communityGroups.get(commId).push(nodeId);
                });

                // 计算最大社区规模
                let maxSize = 0;
                communityGroups.forEach(members => {
                    maxSize = Math.max(maxSize, members.length);
                });

                return {
                    communities: Array.from(communityGroups.values()),
                    count: communityGroups.size,
                    maxSize: maxSize
                };
            },

            // 最短路径分析（使用 Dijkstra 算法）
            findShortestPaths() {
                const nodes = graph.getNodes();
                const edges = graph.getEdges();
                const distances = new Map();
                let totalDistance = 0;
                let pathCount = 0;
                let maxPath = {length: 0, path: []};

                // 对每个节点计算到其他节点的短路径
                nodes.forEach(startNode => {
                    const startId = startNode.getModel().id;
                    const dist = new Map();
                    const prev = new Map();
                    const unvisited = new Set(nodes.map(n => n.getModel().id));

                    dist.set(startId, 0);

                    while (unvisited.size > 0) {
                        // 找到距离最小的未访问节点
                        let minDist = Infinity;
                        let current = null;
                        unvisited.forEach(nodeId => {
                            if (dist.has(nodeId) && dist.get(nodeId) < minDist) {
                                minDist = dist.get(nodeId);
                                current = nodeId;
                            }
                        });

                        if (current === null) break;
                        unvisited.delete(current);

                        // 更新邻居节点的距离
                        edges.forEach(edge => {
                            const model = edge.getModel();
                            if (model.source === current || model.target === current) {
                                const neighbor = model.source === current ? model.target : model.source;
                                const newDist = dist.get(current) + 1;

                                if (!dist.has(neighbor) || newDist < dist.get(neighbor)) {
                                    dist.set(neighbor, newDist);
                                    prev.set(neighbor, current);
                                }
                            }
                        });
                    }

                    // 统计路径信息
                    dist.forEach((distance, endId) => {
                        if (startId !== endId && distance !== Infinity) {
                            totalDistance += distance;
                            pathCount++;

                            if (distance > maxPath.length) {
                                // 重建最长路径
                                const path = [];
                                let current = endId;
                                while (current !== undefined) {
                                    path.unshift(current);
                                    current = prev.get(current);
                                }
                                maxPath = {length: distance, path: path};
                            }
                        }
                    });
                });

                return {
                    avgLength: pathCount > 0 ? totalDistance / pathCount : 0,
                    maxLength: maxPath.length,
                    paths: [maxPath.path]
                };
            }
        };

        // 运行算法
        async function runAlgorithm() {
            const algorithmType = document.getElementById('algorithmSelect').value;
            const button = document.querySelector('.control-button[onclick="runAlgorithm()"]');
            button.disabled = true;
            button.textContent = '计算中...';

            try {
                // 清除之前的高亮
                graph.getNodes().forEach(node => {
                    graph.clearItemStates(node);
                    graph.updateItem(node, {
                        style: {
                            fill: themes.default.node.style.fill
                        }
                    });
                });
                graph.getEdges().forEach(edge => {
                    graph.clearItemStates(edge);
                });

                let result;
                switch (algorithmType) {
                    case 'centrality':
                        result = GraphAlgorithms.calculateCentrality();
                        displayCentralityResult(result);
                        break;
                    case 'community':
                        result = GraphAlgorithms.detectCommunities();
                        displayCommunityResult(result);
                        break;
                    case 'shortestPath':
                        result = GraphAlgorithms.findShortestPaths();
                        displayPathResult(result);
                        break;
                    case 'cycle':
                        alert('环路检测功能正在开发中');
                        break;
                }
            } catch (error) {
                console.error('算法运行错误:', error);
                alert('算法运行出错，请查看控制台了解详情');
            } finally {
                button.disabled = false;
                button.textContent = '运行算法';
            }
        }

        // 显示中心度分析结果
        function displayCentralityResult(result) {
            const top5List = document.getElementById('centralityTop5');
            top5List.innerHTML = '';
            
            result.forEach(([nodeId, score]) => {
                const li = document.createElement('li');
                li.textContent = `节点 ${nodeId}: ${score}`;
                li.className = 'highlight-node';
                top5List.appendChild(li);

                // 高亮相关节点
                const node = graph.findById(nodeId);
                if (node) {
                    graph.setItemState(node, 'highlight', true);
                }
            });
        }

        // 显示社区检测结果
        function displayCommunityResult(result) {
            document.getElementById('communityCount').textContent = result.count;
            document.getElementById('maxCommunitySize').textContent = result.maxSize;
            
            // 为不同社区设置不同颜色
            result.communities.forEach((community, index) => {
                const color = `hsl(${(index * 360) / result.count}, 70%, 70%)`;
                community.forEach(nodeId => {
                    const node = graph.findById(nodeId);
                    if (node) {
                        graph.updateItem(node, {
                            style: {
                                fill: color
                            }
                        });
                    }
                });
            });
        }

        // 显示路径分析结果
        function displayPathResult(result) {
            document.getElementById('avgPathLength').textContent = result.avgLength.toFixed(2);
            document.getElementById('maxPathLength').textContent = result.maxLength;
            
            // 高亮最长路径
            result.paths[0].forEach((nodeId, index) => {
                if (index < result.paths[0].length - 1) {
                    const edge = graph.findEdge(nodeId, result.paths[0][index + 1]);
                    if (edge) {
                        graph.setItemState(edge, 'highlight', true);
                    }
                }
            });
        }
    </script>
</body>
</html>
